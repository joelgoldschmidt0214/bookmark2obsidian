# 要件定義書

## 概要

この仕様書は、ブラウザのブックマークをObsidianのMarkdownファイルに変換する大規模なStreamlitアプリケーション（`app.py`）のリファクタリング要件を定義します。現在のアプリケーションは約4260行あり、「関心の分離」の原則に従って論理的なモジュールに分割し、保守性向上のために包括的なdocstringを追加する必要があります。

## 要件

### 要件1: ディレクトリ構造の作成

**ユーザーストーリー:** 開発者として、整理されたディレクトリ構造が欲しい。そうすることで、コードベースが保守可能になり、Pythonプロジェクトのベストプラクティスに従うことができる。

#### 受け入れ基準

1. リファクタリング開始時に、システムは以下のディレクトリ構造を作成すること：
   - `core/`ディレクトリに`__init__.py`、`parser.py`、`scraper.py`、`generator.py`、`file_manager.py`
   - `ui/`ディレクトリに`__init__.py`、`components.py`
   - `utils/`ディレクトリに`__init__.py`、`models.py`、`error_handler.py`
2. ディレクトリ作成時に、各ディレクトリには`__init__.py`ファイルが含まれること
3. 構造完成時に、すべてのファイルが機能的責任に応じて適切に整理されていること

### 要件2: データモデルの分離

**ユーザーストーリー:** 開発者として、データモデルを独自のモジュールに分離したい。そうすることで、循環依存なしに異なるコンポーネント間でモデルを再利用できる。

#### 受け入れ基準

1. データモデル分離時に、システムは`PageStatus(Enum)`、`Bookmark(dataclass)`、`Page(dataclass)`を`utils/models.py`に移動すること
2. モデル移動時に、システムは必要なすべてのインポート（`Enum`、`dataclass`、`field`、`List`、`Dict`、`Optional`、`datetime`）を含めること
3. モデル分離時に、他のモジュールは相対インポートを使用してこれらのモデルをインポートすること
4. 分離完了時に、循環インポート依存関係が存在しないこと

### 要件3: エラーハンドラーの分離

**ユーザーストーリー:** 開発者として、エラーハンドリングロジックを独自のモジュールに分離したい。そうすることで、エラー管理が集約され、再利用可能になる。

#### 受け入れ基準

1. エラーハンドリング分離時に、システムは`ErrorLogger`クラスと`error_logger`インスタンスを`utils/error_handler.py`に移動すること
2. ErrorLogger移動時に、システムは目的と機能を説明する包括的なdocstringを追加すること
3. エラーハンドリング分離時に、システムは文字列リテラルを使用して型ヒントの潜在的な循環参照問題を処理すること
4. 分離完了時に、エラーロガーが他のモジュールからインポート可能であること

### 要件4: コアロジッククラスの分離

**ユーザーストーリー:** 開発者として、コアビジネスロジッククラスを個別のモジュールに分離したい。そうすることで、各モジュールが単一責任を持ち、保守しやすくなる。

#### 受け入れ基準

1. コアクラス分離時に、システムは`BookmarkParser`を`core/parser.py`に移動すること
2. コアクラス分離時に、システムは`LocalDirectoryManager`を`core/file_manager.py`に移動すること
3. コアクラス分離時に、システムは`WebScraper`を`core/scraper.py`に移動すること
4. コアクラス分離時に、システムは`MarkdownGenerator`を`core/generator.py`に移動すること
5. 各クラス移動時に、システムは必要なすべてのインポートと依存関係を含めること
6. 各クラス移動時に、システムはクラスとその主要なパブリックメソッドに包括的なdocstringを追加すること

### 要件5: UIコンポーネントの分離

**ユーザーストーリー:** 開発者として、UI関連の関数を独自のモジュールに分離したい。そうすることで、プレゼンテーションロジックがビジネスロジックから分離される。

#### 受け入れ基準

1. UIコンポーネント分離時に、システムはすべての表示・検証関数を`ui/components.py`に移動すること
2. UI関数移動時に、システムは`validate_bookmarks_file`、`display_edge_case_summary`、`display_page_list_and_preview`などの関数を含めること
3. UIコンポーネント分離時に、システムは各関数が表示するUI要素を説明するdocstringを追加すること
4. UI分離完了時に、システムはすべてのStreamlit固有のインポートが適切に含まれていることを確認すること

### 要件6: メインアプリケーションのリファクタリング

**ユーザーストーリー:** 開発者として、メインアプリケーションファイルをクリーンで焦点を絞ったものにしたい。そうすることで、最小限の複雑さで明確なエントリーポイントとして機能する。

#### 受け入れ基準

1. メインファイルリファクタリング時に、システムは`app.py`に`main`関数とログ設定のみを保持すること
2. インポートリファクタリング時に、システムは新しいモジュラー構造を参照するようにすべてのインポートを更新すること
3. main関数更新時に、システムはすべてのクラスインスタンス化と関数呼び出しが正しいモジュールを参照することを確認すること
4. リファクタリング完了時に、システムは`main`関数にその目的を説明する包括的なdocstringを追加すること

### 要件7: インポート管理

**ユーザーストーリー:** 開発者として、すべてのモジュール間で適切なインポート管理が欲しい。そうすることで、依存関係が明確になり、インポートエラーがなくなる。

#### 受け入れ基準

1. モジュール作成時に、各モジュールは実際に使用する依存関係のみをインポートすること
2. 相対インポート使用時に、システムは適切な相対インポート構文を使用すること（例：`from ..utils.models import Bookmark`）
3. インポート更新時に、システムは循環依存関係が存在しないことを確認すること
4. インポート管理完了時に、すべてのモジュールがエラーなしでインポート可能であること

### 要件8: ドキュメント強化

**ユーザーストーリー:** 開発者として、コードベース全体に包括的なdocstringが欲しい。そうすることで、コードが自己文書化され、理解しやすくなる。

#### 受け入れ基準

1. docstring追加時に、各クラスはその目的と責任を説明するdocstringを持つこと
2. docstring追加時に、各パブリックメソッドはその機能、パラメータ、戻り値を説明するdocstringを持つこと
3. docstring追加時に、システムはコードベース全体で一貫したdocstring形式を使用すること
4. ドキュメント完了時に、docstringは開発者が実装を読まずにコードを理解するのに十分な情報を提供すること

### 要件9: コード整合性の保持

**ユーザーストーリー:** 開発者として、リファクタリングが既存のすべての機能を保持することを望む。そうすることで、再編成中に機能が失われることがない。

#### 受け入れ基準

1. ファイル間でコード移動時に、システムはすべてのメソッド実装を元の通りに正確に保持すること
2. リファクタリング完了時に、すべての既存機能は元の実装と同じように動作すること
3. クラス移動時に、すべてのクラス属性とメソッドが保持されること
4. リファクタリング完了時に、アプリケーションは機能的変更なしに実行されること

### 要件10: ファイル構成の検証

**ユーザーストーリー:** 開発者として、リファクタリングされた構造が正しいことを検証したい。そうすることで、再編成が成功したことを確信できる。

#### 受け入れ基準

1. リファクタリング完了時に、各モジュールは指定された責任に関連するコードのみを含むこと
2. 構成検証時に、システムはモジュール間で重複コードが存在しないことを確認すること
3. 検証実行時に、すべてのファイルが計画された構造に従って正しいディレクトリにあること
4. 構成検証時に、システムは元の`app.py`がmain関数と必要なインポートのみを含むことを確認すること